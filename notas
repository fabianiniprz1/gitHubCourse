git init -> inicia el repositorio
git add -> agrega los cambios al repositorio
git rm -> prepara el borrado de las modificaciones guardadas anteriormente
git rm --cached -> elimina por completo el add que se habìa generado anteriormente
git status -> permite verificar el estado actual del documento, informa si hay cambios y/o commits sin subir al repositorio
git commit -m 'mensaje' -> realiza el cargue de los cambios hechos al repositorio 
git config --list -> muestra la configuración de git en nuestro ordenador
git config --global user.name nombre -> Cambia el nombre del usuario de la configuracion de git

git log [nombre_archivo] -> permite ver el historial de cambios de un archivo

git log --stat -> permite observar el historial de commits mas detallado

git checkout codigo_del_commit nombre_archivo.extesion_archivo -> permite ver el estado de un archivo en un commit determinado

git checkout master nombre_archivo.extension_archivo -> permite regresar el archivo, al archivo que está en la rama master

git commit -am "mensaje" -> permite hacer un commit sin necesidad de hacer un add previamente, pero sólo funciona con los archivo que ya estén cargados en le proyecto, no se puede con archivos nuevos.

git branch nombre -> crea una rama, una rama permite realizar modificaciones, sin dañar el archivo principal, la master.

git merge nombre_rama -> unifica los cambios de una rama en otra, tener en cuenta que se debe hacer estando "parado" en la rama master, para unir los cambios realizados en otra... todo depende de que quieras.

git log --all --graph --decorate --oneline -> permite ver de forma grafica, las modificaciones que se han realizado a las ramas, es decir, los commits

alias nombre "comando" -> permite generar shortcuts para los comando en consola


git tag -a nombre_version -m "mensaje" id_abreviado_commit -> sirve para crear versiones del programa desarrollado

git tag -> permite ver todos los tag que se han creado

git show-ref --tags -> permite ver todos los tag que se han creado, pero con el id del commit al que pertenecen

cuando se crear un tag, luego se debe hacer un git pull origen master, y luego un git push origen master... luego, eso se va a poder ver reflejado en github

cuando se crear un tag, luego se debe hacer un git pull origen master, y luego un git push origen master... luego, eso se va a poder ver reflejado en github

git tag -d nombre_tag -> borra el tag que deseemos, del repositorio local

git push origen :refs/tags/nombre_tag -> borra el tag del repositorio en la red

gitk --> Muestra de forma grafica, que ha sucedido con todo el proyecto

"suponiendo que estamos trabajando en la red, con un proyecto que no es mio, lo puedo clonar, al momento en que quiera hacer push, debería hacer antes un pull del repositorio en internet, para esto, lo que debería hacer primero es git remote add nombre(upstream) link_repo, esto lo que va a hacer es crear otro origen de datos, diferente al que ya habiamos creado, permitiendo traer las actualizaciones del repositorio en internet"

git stash -> sirve para guardar cambios en temporal, sin necesidad de hacer un commit, es un comando muy util, para no tener que estar bajando todo el repositorio para ver modificaciones


    git shortlog -sn = muestra cuantos commit han hecho cada miembros del equipo.
    git shortlog -sn --all = muestra cuantos commit han hecho cada miembros del equipo hasta los que han sido eliminado
    git shortlog -sn --all --no-merge = muestra cuantos commit han hecho cada miembros quitando los eliminados sin los merges
    git blame ARCHIVO = muestra quien hizo cada cosa linea por linea
    git COMANDO --help = muestra como funciona el comando.
    git blame ARCHIVO -Llinea_inicial,linea_final= muestra quien hizo cada cosa linea por linea indicándole desde que linea ver ejemplo -L35,50
    **git branch -r **= se muestran todas las ramas remotas
    git branch -a = se muestran todas las ramas tanto locales como remotas

